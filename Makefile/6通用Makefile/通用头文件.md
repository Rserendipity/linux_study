# 通用Makefile

## 工程的相似性

每个工程的需求都大差不差：

- 编译部分文件
- 编译所有文件
- 编译时带有不同的选项
- 编译时链接不同的库


那我们有必要每个工程都从零开始写一份Makefile文件吗？

- 从偷懒的角度来说肯定是不想每个工程都从零开始写一份Makefile
- 从效率来说也没有必要每份工程从零写Makefile --- 说不定写Makefile的时间超过写代码的时间
- 解决方案：
  - 把工程编译的共同点拿出来
  - 抽象出一份共用的Makefile，然后包含这份共用的即可
  - 把需要改变的选项的用变量保存，用户重写这些变量就可以实现不同的选项，进而实现不同工程的不同编译方式

> 在写通用Makefile之前需要了解以下知识

## Makefile中的赋值

--- 

基本赋值： =

- 最简单的方式，在等号左边就是变量名，右边就是值

注意：
  - 这种赋值是取最后一次赋值的值，在任意位置定义都可以被使用
  - 以下的Makefile文件，执行 make print 输出结果是 999 ，即最后一次的赋值结果

```
x = 100
print:
    echo $(x)
x = 999
``` 

以下代码将出错，这将出现递归式循环，所以在执行make时会报错

原因：在给x赋值的时候用的是x的值，x还没有被赋值，所以要给x赋值，死递归就这样出现了

```
x = $(x)
``` 

---

覆盖赋值： :=

- 和我们平常写代码的赋值类似，覆盖原有的值，把右边新的值赋给变量
- 注意：
  - Makefile文件在读取到这个赋值时就会把右边的值给赋值过去，如果右边的值为空(或者还没有被赋值)，则将变量赋值为空，不会存在上面基本赋值中的死递归问题

例子：y变量的值为 hello word

```
x := hello
y := $(x) world
```

例子：y变量的值为 word，因为在给y赋值的时候，x还没有被定义，所以y被赋值成后面的 world

```
y := $(x) world
x := hello
```

例子：x变量的值为空，在给x赋值的时候，x还没有被定义

```
x := $(x) world
```

--- 

条件赋值：?=

-  很简单的赋值方式：该变量没有被赋值过，就给它赋值
-  用这个赋值可以实现用户重写编译方式
   -  在通用文件中写上对应的变量，使用条件赋值
   -  条件赋值给定的就是默认值，如果用户没有写，就用默认的值，如果用户自己写了，就不再给对应的变量的赋值，即实现了用户重写编译方式
  
例子：x还没有被赋值，所以值为123

```
x ?= 123
```

例子：x已经被赋值，所以值为999，下面的条件赋值不起作用

```
x = 999
x ?= 123
```

---

追加赋值：+=

-  很简单的赋值方式：给该变量后面追加值
 
例子，x最终的值为 abcdef

```
x = abc
x += def
```

---

## Makefile中文件包含

命令：

- include 文件路径+文件名

作用：
- 对于一些通用的变量定义、通用规则，写在一个文件中，任意目录结构中的Makefile想要使用这些通用的变量或规则时，include指定的文件就好了，而不用在每个Makefile中又重写一遍，即实现了通用Makefile文件

例子：包含~/路径下名为cmake的文件
```
include ~/cmake
```

## 通用Makefile文件的编写

如何编写通用文件：

- 使用 TARGET 变量保存编译目标
- 使用 COMPILER 变量保存编译器信息
- 使用 SOURCE 变量保存需要编译的文件
- 使用 OPTION 变量保存编译选项
- 利用条件赋值，给这些变量赋值，即用户不写这些变量时的初始值

最终的通用文件：

- 可以把如下文件放在家目录下，每次写Makefile文件就只需要包含家目录下的该文件即可
```
# 伪目标声明，clean始终执行
.PHONY: clean

# 默认目标   -- main
# 默认编译器 -- 让系统指定，即 CXX 系统变量
# 默认源文件 -- 当前目录下全部.c文件
# 默认选项   -- 空
TARGET   	?= main
COMPILER	?= $(CXX)
SOURCE   	?= $(wildcard *.c)
OPTION   	?= 

# 覆盖赋值，不允许用户重写
OBJ:=$(patsubst %.c,%.o, $(notdir $(SOURCE)))

$(TARGET):$(OBJ)
	$(COMPILER) $(OPTION) $(OBJ) -o $(TARGET)

%.o:%.c
	$(COMPILER) -c $^ -o $@

clean:
	$(RM) $(TARGET) *.o
```