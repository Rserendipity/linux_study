# 伪目标与模式匹配

## 伪目标

先来看一个现象：

- 在项目中创建一个名为"clean"的文件
- 再使用make clean清除项目

效果如下：

- make: 'clean' is up to date.

![在这里插入图片描述](https://img-blog.csdnimg.cn/d9fad71140c3488c983d2f360a5a2ddc.png)

可以发现根本没有被执行，clean被认为是一个文件了

---

为什么会存在伪目标？

- 由于目标 clean 等不需要依赖文件，所以如果在项目中存在 "clean" 这个文件的时候，make便找不到 "clean" 的任何依赖文件，所以始终认为"clean"文件是最新的，于是不会执行我们想要的 clean 中的命令

- 为了解决这个问题，便有了伪目标这个概念
- 被伪目标声明的目标被调用时，始终会执行clean中的命令，进而解决问题

如何声明和使用伪目标：

- .PHONY:(内容)
  - .PHONY不可缺少，这是一个标识，冒号后的内容便是声明的伪目标
- 使用命令make clean，clean命令始终会被执行
  - 被伪目标声明的目标会始终执行，也就是说忽略了make的优势之一：只编译被改动过的文件
- 可以声明任意目标为伪目标

改造项目文件，使得clean命令始终被执行：

``` c
.PHONY: clean # 重点

OBJ=main.o Add.o
TARGET=main

${TARGET}: ${OBJ}
 CXX ${OBJ} -o ${TARGET}

Add.o: Add.c
 CXX -c $^
main.o: main.c
 CXX -c $^

clean:
 RM *.o $(TARGET)
```

## 模式匹配

为什么会存在模式匹配？

- 通过检测上下文，匹配所需要的变量，完成目标编译


如何使用模式匹配：

- %
  - "%"是一个标识，表明开始通配，可以匹配上下文中所需要的依赖
  
例子：

``` c
%.o:%.c
  $(CXX) -c $^ -o $@
```

解释：

- 生成的目标是“通配出来的”，所需要的依赖也是“通配出来的”
- 例如 main.o 的生成
  1. 检测到需要生成main.o
  2. 匹配到依赖是main.c
  3. 在命令中使用 $(CXX) 来编译 main.c 从而生成main.o
- 其他的 .o 文件的生成也是同理，于是我们使用了一个语句，解决了所有的 .o 文件的生成
- 我们只需要在 TARGET 变量中添加所需要的 .o 文件，通配就可以帮我们解决对应的编译问题，不需要重复的书写对应的生成 

改造项目文件

- 仅需要在OBJ中添加目标，不需要修改其他内容，即可添加项目文件：

``` c
.PHONY: clean

OBJ=main.o Add.o
TARGET=main

${TARGET}: ${OBJ}
 CXX ${OBJ} -o ${TARGET}

%.o:%.c # 重点
	$(CXX) -c $^ -o $@

clean:
 RM *.o $(TARGET)
```
